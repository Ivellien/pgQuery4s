\section{Using native library}
Now we have to use the function from the \texttt{libpg\_query} library, which returns the parse tree in the form of JSON. Then we will convert the JSON into our case class structure. That is not as simple as it looks, and the reason for that is the conflict between native code and java byte code. 

\subsection{Native code and byte code}
Native code is compiled to run on a specific processor. Examples of languages that produce native code after compilation are C, C++. That means, every time we want to run our C program, it has to be recompiled for that specific operating system or processor.

Java byte code, on the other hand, is compiled source code from i.e. Java, Scala. Byte code is then translated to machine code using JVM. Any system that has JVM can run the byte code, does not matter which operating system it uses. That is why Java and Scala as well, are platform-independent.

Now because of this difference, we can't directly "import" the C library into our Scala code, but we have to use workaround, that enables this.

\subsection{Java native interface}
JNI is programming interface for writing Java native methods.\cite{JNI} It is used to enable Java code to use native applications and libraries. 

My earlier version of the project used JNI directly. I used \texttt{javah} command to generate C header file for \texttt{PgQueryWrapper}. The JNI C header file works as a bridge between native code and the Scala program. Now we can call \texttt{libpg\_query} inside the new C file, then compile it and create our shared library. The next step is loading the .so file into the Scala program. That was achieved by \texttt{System.loadLibrary} function. The system uses the local \texttt{java.library.path}, so it was necessary to add the path of the file with the shared library to the path variable.

\subsection{Issues}
The raw JNI approach worked fine for a single module. However, the project is now separated into several submodules (native, parser, macros, core). By default, the sbt task runs in the same JVM as sbt.\cite{sbt fork} Using for example \texttt{sbt test} command runs tests for each submodule at the same time and since multiple submodules try to access the native library. Tests for each submodule are run on the same JVM, but different ClassLoader. However, the created shared library can be linked only once, so the execution fails with \texttt{UnsatisfiedLinkError}. 

\subsection{sbt-jni}
To fix these issues, I used an existing JNI wrapper for Scala called \texttt{sbt-jni}. It is a suite of sbt plugins for simplifying the creation and distribution of JNI programs. To name the ones I used, \texttt{JniJavah} works as a wrapper around the \texttt{javah} command to generate headers for classes with \texttt{@native methods}. Next one I used is \texttt{JniLoad}, which enables correct loading of shared libraries through \texttt{@nativeLoader} annotation.

Another applied fix is the \texttt{fork := true} setting in \texttt{build.sbt}. This causes the task to run in different process and JVM. This gets rid of the \texttt{UnsatisfiedLinkError}. 


