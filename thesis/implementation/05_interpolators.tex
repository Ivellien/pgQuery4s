\section{Scala custom interpolators}
\subsection{What are interpolators?}
Since version 2.10, Scala offers a new possibility of string interpolation.~\cite{String interpolation} This allows me to create generic queries with variables instead of direct values. That way we can define and reuse queries, without unnecessary copying and pasting of code. The idea behind Scala interpolation is the processing of string literals. For example, this code  \verb|id"Interpolated text"| is transformed into the call of method "id" on instance of \texttt{StringContext} class. By extending this existing class we can introduce custom interpolators, which allows for a clear definition of these generic query definitions.
\bigskip
\newline
\textbf{String concatenation}
\begin{lstlisting}[language=scala, basicstyle=\ttfamily, showstringspaces=false]
val query: String = 
 "SELECT " + columnName + " FROM students"
PgQueryParser.parse(query)
\end{lstlisting}
\bigskip
\textbf{String interpolation}
\begin{lstlisting}[language=scala, basicstyle=\ttfamily, showstringspaces=false]
query"SELECT $columnName FROM students"
\end{lstlisting}

\subsection{Runtime implementation}
The first version of the library used only runtime validation. I defined my custom interpolator called \textit{query}. Inside the interpolator, the arguments were merged into \texttt{StringContext}. Following that, the finished string got parsed using \texttt{PgQueryParse.parse} method.
