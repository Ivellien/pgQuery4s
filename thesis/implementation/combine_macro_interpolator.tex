\section{Combining interpolators and macros}
\subsection{Parameterized queries in PostgreSQL}
Before we can get to the part, where our custom interpolator is simple call to the macro, which does the validation, we have to talk about implementation of placeholders in PostgreSQL. There is existing support for something called \textit{Prepared statements}. These allow for placeholders inside the query, in form of \textbf{\$n} where \textbf{n} must be positive integer.  

During compile time each variable in our interpolated string is during known by name only. In macro first thing we have to do is build the string itself from the \textit{StringContext} and the arguments. To keep the final query valid, each of the arguments has to be replaced with \textit{\$n}. 
Let's say we have the following example.
\begin{lstlisting}[language=scala, showstringspaces=false]
query"SELECT $columnName FROM students WHERE $expression"
\end{lstlisting}
If we tried to pass this string directly to the libpg\_query, we would get empty JSON result, because this is not a valid query. That means it is neccessary for us to transform it into this form.
\begin{lstlisting}[language=scala, showstringspaces=false]
query"SELECT $1 FROM students WHERE $2"
\end{lstlisting}
This returns correct parse tree, where each of the placeholders contains node of ParamRef type. 


\subsection{Transforming syntax tree}
