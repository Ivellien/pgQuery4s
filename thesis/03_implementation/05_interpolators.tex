\section{Scala custom interpolators}
\subsection{What are interpolators?}
Since version 2.10, Scala offers a new possibility of string interpolation.~\cite{String interpolation} This allows me to create generic queries with variables instead of direct values. That way, we can define and reuse queries without unnecessary copying and pasting of code. The idea behind Scala interpolation is the processing of string literals. For example, this code  \verb|id"Interpolated text"| is transformed into the call of method \texttt{id} on instance of \texttt{StringContext} class. By extending this existing class, we can introduce custom interpolators, which allows for a clear definition of these generic query definitions.
\bigskip
\newline
\begin{lstlisting}[language=scala, basicstyle=\ttfamily, showstringspaces=false, caption={Example of \texttt{String} concatenation}]
val query: String = 
 "SELECT " + columnName + " FROM students"
PgQueryParser.parse(query)
\end{lstlisting}
\bigskip
\begin{lstlisting}[language=scala, basicstyle=\ttfamily, showstringspaces=false, caption={Example of \texttt{String} interpolation}]
query"SELECT $columnName FROM students"
\end{lstlisting}

\subsection{Runtime implementation}
Although the goal of this project is to validate queries during compilation and transform the interpolated string to \texttt{Node} at compile time, the runtime validation is important as well. Parse trees of queries are accessible at runtime. Simply use the built-in string interpolator to create the query. The parse tree can be generated by the \texttt{parse} method of \texttt{PgQueryParser}.